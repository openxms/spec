# XMS Specification v0.0.1

**XMS (eXchange Metadata Standard)** defines a lightweight `key=value;...` format for attaching metadata to virtual currency transactions in kromer.

---

## 1. Format Overview

An XMS metadata string consists of:

1. **Version marker**: `xms/N` where N is the version number
2. **Key-value pairs** separated by semicolons `;`

**Examples:**

- `xms/1;username=steve;useruuid=550e8400e29b41d4a716446655440000;item="diamond_sword";return=k123456789`

---

## 2. Syntax Rules

### 2.1 Basic Format

- XMS v1+ MUST begin with `xms/N;` where `N` is the version number
- CommonMeta (v0) has NO version prefix and falls back to basic `key=value;` parsing
- Key-value pairs use `=` separator
- Pairs separated by `;`
- Multiple consecutive semicolons are collapsed to single separators
- Trailing semicolons are ignored

### 2.2 Keys

- Keys: lowercase letters, digits, `_`, `.` only
- Keys are normalized to lowercase during parsing
- Maximum nesting depth: 5 levels (e.g., `key1.key2.key3.key4.value`)
- Empty keys are preserved in entries but not structured data
- Duplicate keys: last occurrence wins

### 2.3 Values

- Values can be plain text or quoted with `"`
- Values containing `;` or `=` SHOULD be quoted
- Escape sequences in quotes: `\"` for quotes, `\\` for backslashes
- Whitespace around `=` and `;` is trimmed after parsing
- `key=;` results in null/nil/undefined value
- `key="";` results in empty string value
- `key;` (no `=`) is equivalent to `key=;`

### 2.4 Fallback Behavior

- Malformed XMS strings fall back to CommonMeta parsing
- Malformed quotes trigger CommonMeta fallback
- CommonMeta supports non-key values (bare tokens without `=`)

---

## 3. Common Keys

### 3.1 User Information

- **`username`** - User's in-game name, max 16 chars (string, optional)
- **`useruuid`** - User's UUID with/without dashes (string, optional)

### 3.2 System References

- **`message`** - User message, max 255 chars (string, optional)
- **`return`** - Return reference/callback identifier (string, optional)

### 3.3 Error Handling

- **`error.*`** - Error information namespace (namespace | string, optional)
  - **`code`** - Error code (string, optional)
  - **`message`** - Error message, max 255 chars (string, optional)
- **`error`** - Error message (string, optional)

---

## 4. Data Structures

### 4.1 Arrays

Arrays are represented using numeric indices:

```
items.0=sword
items.1=shield
items.2=potion
```

### 4.2 Nested Objects

Nested structures use dot notation with flattened representation:

```
ref.item=diamond_sword    # Creates both ref["item"] and ["ref.item"]
user.stats.level=25       # Creates nested structure user["stats"]["level"] and ["user.stats.level"]
```

---

## 5. Type Coercion (Optional)

### 5.1 Boolean Coercion

- `"true"` → `true`
- `"false"` → `false`
- Case-insensitive matching
- Custom coercion rules may be provided by implementation

### 5.2 Numeric Coercion

- Strings matching number patterns may be coerced to numbers
- Implementation-specific behavior

### 5.3 Null Handling

- `key=;` → `null`/`nil`/`undefined`
- `key="";` → empty string `""`

---

## 6. Output Format

Parsers MUST return an object with the following structure:

```json
{
  "version": 1, // 0 for CommonMeta, 1+ for XMS
  "isFallback": false, // true if fell back to CommonMeta
  "entries": [
    // Raw key-value pairs in order
    {
      "name": "key",
      "value": "value"
    }
  ],
  "data": {
    // Structured data with nesting
    "key": "value",
    "nested": {
      "key": "value"
    }
  }
}
```

---

## 7. Performance Considerations

### 7.1 Parsing Optimization

- Maximum nesting depth of 5 levels prevents deep recursion
- Early fallback detection for malformed XMS
- Efficient semicolon normalization
- Single-pass parsing where possible

### 7.2 Memory Management

- Preserve unknown keys without excessive memory overhead
- Limit individual value sizes (255 chars for messages, 16 chars for usernames)
- No hard limit on total metadata length for transaction flexibility

---

## 8. Input Sanitization & Security

### 8.1 Size Limits

- Username: 16 characters maximum
- Messages: 255 characters maximum
- Error messages: 255 characters maximum
- No total metadata size limit (transaction-dependent)

### 8.2 Character Validation

- Keys must match pattern: `[a-z0-9_.]+`
- Values should be validated by application context
- UTF-8 not required (ComputerCraft compatibility)

### 8.3 Error Handling

- Graceful degradation to CommonMeta on parse errors
- Preserve partial data when possible
- Document malformed input behavior

---

## 9. Examples

### 9.1 XMS v1 Parsing

**Input:** `xms/1;username=steve;useruuid=550e8400e29b41d4a716446655440000;item="diamond_sword";return=k123456789`

**Output:**

```json
{
  "version": 1,
  "isFallback": false,
  "entries": [
    { "name": "username", "value": "steve" },
    { "name": "useruuid", "value": "550e8400e29b41d4a716446655440000" },
    { "name": "item", "value": "diamond_sword" },
    { "name": "return", "value": "k123456789" }
  ],
  "data": {
    "item": "diamond_sword",
    "username": "steve",
    "useruuid": "550e8400e29b41d4a716446655440000",
    "return": "k123456789"
  }
}
```

### 9.2 CommonMeta Fallback

**Input:** `username=steve;useruuid=550e8400e29b41d4a716446655440000;return=k123456789;diamond_sword`

**Output:**

```json
{
  "version": 0,
  "isFallback": true,
  "entries": [
    { "name": "username", "value": "steve" },
    { "name": "useruuid", "value": "550e8400e29b41d4a716446655440000" },
    { "name": "return", "value": "k123456789" },
    { "name": "diamond_sword", "value": "" }
  ],
  "data": {
    "username": "steve",
    "useruuid": "550e8400e29b41d4a716446655440000",
    "return": "k123456789",
    "diamond_sword": ""
  }
}
```

### 9.3 Array Example

**Input:** `xms/1;items.0=sword;items.1=shield;items.2=potion;count=3`

**Output:**

```json
{
  "version": 1,
  "isFallback": false,
  "entries": [
    { "name": "items.0", "value": "sword" },
    { "name": "items.1", "value": "shield" },
    { "name": "items.2", "value": "potion" },
    { "name": "count", "value": "3" }
  ],
  "data": {
    "items": {
      "0": "sword",
      "1": "shield",
      "2": "potion"
    },
    "count": "3"
  }
}
```

---

## 10. Implementation Guidelines

### 10.1 Library Requirements

- Support both XMS and CommonMeta parsing
- Preserve unknown keys for forward compatibility
- Handle malformed input gracefully
- Provide clear error messages for debugging

### 10.2 Extension Support

- Document any custom keys used in implementations
- Maintain compatibility with core XMS format
- Consider namespace prefixes for custom extensions

### 10.3 Validation

- Validate format structure before detailed parsing
- Check key naming conventions
- Enforce size limits where specified
- Provide configurable coercion rules

---

**Version:** 0.0.1  
**Date:** 2025-10-04
